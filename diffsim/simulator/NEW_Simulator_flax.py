import jax.numpy as numpy
from jax import lax

import flax.linen as nn

from dataclasses import dataclass
from . ElectronGenerator import ElectronGenerator, init_electron_generator
from . Diffusion         import Diffusion,         init_diffusion
from . Lifetime          import Lifetime,          init_lifetime
from . NNSensorResponse  import NNSensorResponse,  init_nnsensor_response
from . NNSensorResponse  import NNSensorResponse,  init_nnsensor_response
from . SipmResponse      import SipmResponse,      init_sipm_response
# from . GSensorResponse   import GSensorResponse,   init_gsensor_response

def load_balance_electrons(electrons, n_electrons, M : int = 100000):
    '''
    Take as input the un-balanced list of electrons, which 
    is zero padded in multiple dimensions.
    Return instead a flattened list of electrons of shape [B, M]
    where B is the batch size and M is a max-per-batch.

    In situations where n_electrons > M, this creates a logical 
    error but JAX has no run-time error checking
    '''

    # Doing this in the most simple way possible for now:

    end_points   = numpy.cumsum(n_electrons)
    start_points = end_points - n_electrons


    def loop_iteration(i, output_array):
        def inner_loop(j, inner_array):
            inner_array = inner_array.at[i+j].set(electrons[i][j])
            return inner_array
        
        # Get the start value:
        start = start_points[i]
        end   = end_points[i]
        output_array = lax.fori_loop(start, end, body_fun=inner_loop, init_val=output_array)
        # output_array = output_array.at[start:end].set(electrons[i])
        return output_array

    output_electrons = numpy.zeros((M, 3))
    
    non_zero = numpy.argwhere(n_electrons)
    N_deps   = non_zero[-1][0]

    output_electrons = lax.fori_loop(
        lower = 0,
        upper = n_electrons.shape[-1], # N_deps?
        body_fun = loop_iteration,
        init_val = output_electrons
    )

    mask = numpy.zeros((M,))
    N = numpy.sum(n_electrons)
    mask = mask.at[0:N].set(1.0)



    return output_electrons, mask.reshape((-1,1))

    


class NEW_Simulator(nn.Module):

    eg:       ElectronGenerator
    diff:     Diffusion
    lifetime: Lifetime
    pmt_s2:   NNSensorResponse
    sipm_s2:  SipmResponse

    @nn.compact
    def __call__(self, energies_and_positions):

        electrons, n_electrons = self.eg(energies_and_positions)

        balanced_electrons, mask = load_balance_electrons(electrons, n_electrons)

        diffused = self.diff(balanced_electrons)


        # mask = self.lifetime(diffused, n_electrons)


        # pmts only depend on xy:
        diffused_xy = diffused[:,0:2]
        diffused_z  = diffused[:,2]

        # Simulate the number of photons generated by the EL region.
        # It's computed as a flat gain and then has some learned, local adjustment.

        el_gain_v = self.variable(
                "params", "el_gain",
                lambda s : 1e-1 * numpy.ones(s, dtype=diffused.dtype),
                (1,),
            )
        # This actually fetches the value:
        el_gain = (el_gain_v.value)**2


        el_photons = numpy.exp(el_gain)*mask
        # el_photons = el_gain*(1 + self.el_sim(diffused_xy) ) 

        # This is getting normalized to the range (-1,1):
        pmt_response = self.pmt_s2(el_photons, diffused_xy, diffused_z)

        sipm_response = self.sipm_s2(el_photons, diffused_xy, diffused_z)


        return {
            # "N_e"   : n_electrons,
        	"S2Pmt" : pmt_response,
        	"S2Si"  : sipm_response
    	}



def init_NEW_simulator(NEW_Physics):

    all_rng_keys = []

    eg, eg_rng_keys = init_electron_generator(NEW_Physics.electron_generator)

    if eg_rng_keys is not None:
        all_rng_keys += eg_rng_keys

    diff, diff_rng_keys = init_diffusion(NEW_Physics.diffusion)
    if diff_rng_keys is not None:
        all_rng_keys += diff_rng_keys


    lifetime, lifetime_rng_keys = init_lifetime()
    if lifetime_rng_keys is not None:
        all_rng_keys += lifetime_rng_keys


    pmt_s2, _ = init_nnsensor_response(NEW_Physics.pmt_s2)
    sipm_s2, _ = init_sipm_response(NEW_Physics.sipm_s2)
    # sipm_s2, _ = init_gsensor_response(NEW_Physics.sipm_s2)

    simulator = NEW_Simulator(
        eg       = eg,
        diff     = diff,
        lifetime = Lifetime(),
        pmt_s2   = pmt_s2,
        sipm_s2  = sipm_s2,
    )


    return simulator, all_rng_keys
